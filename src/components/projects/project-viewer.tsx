"use client"

import { useEffect, useRef, useState, useCallback } from "react"
import Map from "ol/Map"
import View from "ol/View"
import ImageLayer from "ol/layer/Image"
import VectorLayer from "ol/layer/Vector"
import VectorSource from "ol/source/Vector"
import Static from "ol/source/ImageStatic"
import Projection from "ol/proj/Projection"
import { defaults as defaultControls } from "ol/control"
import { defaults as defaultInteractions } from "ol/interaction"
import Feature from "ol/Feature"
import { Point } from "ol/geom"
import { Style, Circle as CircleStyle, Fill, Stroke, Text } from "ol/style"
import { Polygon } from "ol/geom"
import "ol/ol.css"
import * as pdfjsLib from "pdfjs-dist"
import { findMatchingPositions, pdfToOLCoords, type TextPosition } from "@/lib/highlight-matcher"

import type { SignageItem } from "@/lib/stores/project-store"
import { cn } from "@/lib/utils"

// Configure PDF.js worker
if (typeof window !== "undefined") {
  pdfjsLib.GlobalWorkerOptions.workerSrc = "/pdf.worker.min.mjs"
}

// Cache for pre-rendered pages: documentId -> pageNumber -> { dataUrl, width, height }
interface CachedPage {
  dataUrl: string
  width: number
  height: number
}
const pageCache: Record<string, Record<number, CachedPage>> = {}

interface QuickAddCoords {
  screenX: number // Screen position for form placement
  screenY: number
  pdfX: number // Normalized PDF coordinates (0-1)
  pdfY: number
}

interface SymbolPickerCoords {
  pdfX: number // Normalized PDF coordinates (0-1)
  pdfY: number
}

interface ProjectViewerProps {
  documentId: string | null
  pageNumber: number
  totalPages?: number
  items: SignageItem[]
  selectedItemId: string | null
  onSelectItem: (id: string | null) => void
  quickAddMode: boolean
  onQuickAddClick: (coords: QuickAddCoords) => void
  symbolPickerMode?: boolean
  onSymbolPickerClick?: (coords: SymbolPickerCoords) => void
  extractionStatus?: "not_started" | "extracting" | "queued" | "completed" | "failed" | "no_documents"
  highlightTerms?: string[]
}

export function ProjectViewer({
  documentId,
  pageNumber,
  totalPages = 1,
  items,
  selectedItemId,
  onSelectItem,
  quickAddMode,
  onQuickAddClick,
  symbolPickerMode = false,
  onSymbolPickerClick,
  extractionStatus,
  highlightTerms = [],
}: ProjectViewerProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const mapRef = useRef<Map | null>(null)
  const imageLayerRef = useRef<ImageLayer<Static> | null>(null)
  const vectorSourceRef = useRef<VectorSource | null>(null)
  const highlightSourceRef = useRef<VectorSource | null>(null)
  const [zoom, setZoom] = useState(100)
  const [pageSize, setPageSize] = useState({ width: 612, height: 792 })
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [pdfUrl, setPdfUrl] = useState<string | null>(null)
  const [pageDataUrl, setPageDataUrl] = useState<string | null>(null)
  const pdfDocRef = useRef<pdfjsLib.PDFDocumentProxy | null>(null)

  // Use refs to access current values in map event handlers
  const quickAddModeRef = useRef(quickAddMode)
  const onQuickAddClickRef = useRef(onQuickAddClick)
  const symbolPickerModeRef = useRef(symbolPickerMode)
  const onSymbolPickerClickRef = useRef(onSymbolPickerClick)
  const onSelectItemRef = useRef(onSelectItem)
  const selectedItemIdRef = useRef(selectedItemId)
  const pageSizeRef = useRef(pageSize)

  // Keep refs in sync with props
  useEffect(() => { quickAddModeRef.current = quickAddMode }, [quickAddMode])
  useEffect(() => { onQuickAddClickRef.current = onQuickAddClick }, [onQuickAddClick])
  useEffect(() => { symbolPickerModeRef.current = symbolPickerMode }, [symbolPickerMode])
  useEffect(() => { onSymbolPickerClickRef.current = onSymbolPickerClick }, [onSymbolPickerClick])
  useEffect(() => { onSelectItemRef.current = onSelectItem }, [onSelectItem])
  useEffect(() => { selectedItemIdRef.current = selectedItemId }, [selectedItemId])
  useEffect(() => { pageSizeRef.current = pageSize }, [pageSize])

  // pageDataUrl is now generated by PDF.js rendering effect

  // Fetch page info to get dimensions and PDF URL
  useEffect(() => {
    if (!documentId) return

    const fetchInfo = async () => {
      try {
        const res = await fetch(`/api/documents/${documentId}/info`)
        if (res.ok) {
          const data = await res.json()
          // Store PDF URL for client-side rendering
          if (data.pdfUrl) {
            setPdfUrl(data.pdfUrl)
          }
          if (data.pages?.[pageNumber - 1]) {
            const pg = data.pages[pageNumber - 1]
            setPageSize({ width: pg.width || 612, height: pg.height || 792 })
          }
        }
      } catch (e) {
        // Use defaults
      }
    }
    fetchInfo()
  }, [documentId, pageNumber])

  // Helper to render a single page to data URL with dimensions
  const renderPageToCached = useCallback(async (
    pdfDoc: pdfjsLib.PDFDocumentProxy,
    pageNum: number
  ): Promise<CachedPage> => {
    const page = await pdfDoc.getPage(pageNum)
    const scale = 150 / 72 // 150 DPI
    const viewport = page.getViewport({ scale })

    // Get original PDF page dimensions (at 72 DPI)
    const pdfWidth = viewport.width / scale
    const pdfHeight = viewport.height / scale

    const canvas = document.createElement("canvas")
    const context = canvas.getContext("2d")
    if (!context) throw new Error("Could not get canvas context")

    canvas.width = Math.floor(viewport.width)
    canvas.height = Math.floor(viewport.height)

    await page.render({
      canvasContext: context,
      viewport,
      canvas,
    }).promise

    return {
      dataUrl: canvas.toDataURL("image/png"),
      width: pdfWidth,
      height: pdfHeight,
    }
  }, [])

  // Render PDF page client-side using PDF.js with caching and preloading
  useEffect(() => {
    if (!pdfUrl || !pageNumber || !documentId) return

    const currentPdfUrl = pdfUrl
    const currentDocId = documentId
    let cancelled = false

    // Check cache first for instant display
    const cached = pageCache[currentDocId]?.[pageNumber]

    if (cached) {
      // Instant display from cache - set dimensions first to avoid warping
      setPageSize({ width: cached.width, height: cached.height })
      setPageDataUrl(cached.dataUrl)
      setLoading(false)
      setError(null)

      // Still preload adjacent pages in background
      preloadAdjacentPages()
      return
    }

    // Only show loading if no existing page displayed
    const isInitialLoad = !pageDataUrl

    async function renderCurrentPage() {
      try {
        if (isInitialLoad) {
          setLoading(true)
        }
        setError(null)

        // Load or reuse PDF document
        if (!pdfDocRef.current) {
          pdfDocRef.current = await pdfjsLib.getDocument({
            url: currentPdfUrl,
            verbosity: 0, // Suppress warnings like "TT: undefined function"
          }).promise
        }

        if (cancelled) return

        const pdfDoc = pdfDocRef.current
        const rendered = await renderPageToCached(pdfDoc, pageNumber)

        if (cancelled) return

        // Cache the rendered page
        if (!pageCache[currentDocId]) {
          pageCache[currentDocId] = {}
        }
        pageCache[currentDocId][pageNumber] = rendered

        // Set dimensions first, then data URL to avoid warping
        setPageSize({ width: rendered.width, height: rendered.height })
        setPageDataUrl(rendered.dataUrl)
        setLoading(false)

        // Preload adjacent pages after current page is displayed
        preloadAdjacentPages()
      } catch (err) {
        if (cancelled) return
        const errorMessage = err instanceof Error ? err.message : "Failed to render page"
        setError(errorMessage)
        setLoading(false)
      }
    }

    async function preloadAdjacentPages() {
      if (!pdfDocRef.current || cancelled) return

      const pdfDoc = pdfDocRef.current
      const numPages = pdfDoc.numPages
      const pagesToPreload = [pageNumber - 1, pageNumber + 1].filter(
        p => p >= 1 && p <= numPages
      )

      for (const preloadPage of pagesToPreload) {
        if (cancelled) return

        // Skip if already cached
        if (pageCache[currentDocId]?.[preloadPage]) continue

        try {
          const rendered = await renderPageToCached(pdfDoc, preloadPage)
          if (cancelled) return

          if (!pageCache[currentDocId]) {
            pageCache[currentDocId] = {}
          }
          pageCache[currentDocId][preloadPage] = rendered
        } catch {
          // Ignore preload errors
        }
      }
    }

    renderCurrentPage()

    return () => {
      cancelled = true
    }
  }, [pdfUrl, pageNumber, documentId, renderPageToCached])

  // Cleanup PDF document on unmount or document change
  useEffect(() => {
    // Reset page data URL when document changes to trigger loading state
    setPageDataUrl(null)

    return () => {
      if (pdfDocRef.current) {
        pdfDocRef.current.destroy()
        pdfDocRef.current = null
      }
      // Clear cache for this document
      if (documentId) {
        delete pageCache[documentId]
      }
    }
  }, [documentId])

  // Initialize map
  useEffect(() => {
    if (!containerRef.current || mapRef.current) return

    const vectorSource = new VectorSource()
    vectorSourceRef.current = vectorSource

    // Highlight layer for search results (below marker layer)
    const highlightSource = new VectorSource()
    highlightSourceRef.current = highlightSource

    const highlightLayer = new VectorLayer({
      source: highlightSource,
      style: new Style({
        fill: new Fill({ color: "rgba(255, 235, 59, 0.5)" }), // Yellow with transparency
        stroke: new Stroke({ color: "rgba(255, 193, 7, 0.8)", width: 1 }),
      }),
      zIndex: 1,
    })

    const vectorLayer = new VectorLayer({
      source: vectorSource,
      zIndex: 2, // Above highlight layer
      style: (feature) => {
        const isSelected = feature.get("id") === selectedItemIdRef.current
        const status = feature.get("status")

        let color = "#3b82f6" // blue for pending
        if (status === "approved") color = "#22c55e" // green
        if (status === "skipped") color = "#94a3b8" // gray

        return new Style({
          image: new CircleStyle({
            radius: isSelected ? 14 : 10,
            fill: new Fill({ color: isSelected ? color : `${color}cc` }),
            stroke: new Stroke({
              color: "#ffffff",
              width: isSelected ? 3 : 2,
            }),
          }),
          text: new Text({
            text: feature.get("label") || "",
            font: "bold 11px sans-serif",
            fill: new Fill({ color: "#ffffff" }),
            offsetY: 1,
          }),
        })
      },
    })

    // Placeholder projection - will be updated when image loads
    const projection = new Projection({
      code: "PDF",
      units: "pixels",
      extent: [0, 0, pageSize.width * 2, pageSize.height * 2],
    })

    const map = new Map({
      target: containerRef.current,
      layers: [highlightLayer, vectorLayer],
      view: new View({
        projection,
        center: [pageSize.width, pageSize.height],
        resolution: 1,
        minResolution: 0.1,
        maxResolution: 20,  // Allow zooming out far enough for large drawings
      }),
      controls: defaultControls({ zoom: false, rotate: false, attribution: false }),
      interactions: defaultInteractions({
        doubleClickZoom: true,
        mouseWheelZoom: true,
        pinchZoom: true,
        pinchRotate: false,
      }),
    })

    // Track zoom
    map.getView().on("change:resolution", () => {
      const res = map.getView().getResolution()
      if (res) {
        setZoom(Math.round((1 / res) * 100))
      }
    })

    // Click handler
    map.on("click", (e) => {
      const features = map.getFeaturesAtPixel(e.pixel, { hitTolerance: 15 })
      if (features && features.length > 0) {
        const id = features[0].get("id")
        if (id) {
          onSelectItemRef.current(id)
          return
        }
      }

      // Calculate normalized coordinates (shared by both modes)
      const coord = e.coordinate
      const dpi = 150
      const scale = dpi / 72
      const currentPageSize = pageSizeRef.current
      const extentWidth = currentPageSize.width * scale
      const extentHeight = currentPageSize.height * scale
      const pdfX = Math.max(0, Math.min(1, coord[0] / extentWidth))
      const pdfY = Math.max(0, Math.min(1, 1 - (coord[1] / extentHeight))) // Flip Y

      if (symbolPickerModeRef.current && onSymbolPickerClickRef.current) {
        // Symbol picker mode - search for similar symbols
        onSymbolPickerClickRef.current({ pdfX, pdfY })
      } else if (quickAddModeRef.current) {
        // Quick add mode - add item at location
        onQuickAddClickRef.current({
          screenX: e.pixel[0] + (containerRef.current?.getBoundingClientRect().left || 0),
          screenY: e.pixel[1] + (containerRef.current?.getBoundingClientRect().top || 0),
          pdfX,
          pdfY,
        })
      } else {
        onSelectItemRef.current(null)
      }
    })

    // Cursor
    map.on("pointermove", (e) => {
      const hit = map.hasFeatureAtPixel(e.pixel, { hitTolerance: 15 })
      const target = map.getTargetElement()
      if (target) {
        if (symbolPickerModeRef.current) {
          target.style.cursor = "crosshair"
        } else if (quickAddModeRef.current) {
          target.style.cursor = "crosshair"
        } else {
          target.style.cursor = hit ? "pointer" : "grab"
        }
      }
    })

    mapRef.current = map

    // ResizeObserver to handle container size changes and initial layout
    let isFirstResize = true
    const resizeObserver = new ResizeObserver(() => {
      if (mapRef.current) {
        mapRef.current.updateSize()
        // On first resize (initial layout), fit the view to extent
        if (isFirstResize) {
          isFirstResize = false
          const view = mapRef.current.getView()
          const extent = view.getProjection().getExtent()
          if (extent && extent[2] > 0 && extent[3] > 0) {
            view.fit(extent, { padding: [20, 20, 20, 20], duration: 0 })
          }
        }
      }
    })
    resizeObserver.observe(containerRef.current)

    return () => {
      resizeObserver.disconnect()
      map.setTarget(undefined)
      mapRef.current = null
    }
  }, [])

  // Update OpenLayers image when page is rendered
  useEffect(() => {
    if (!mapRef.current || !pageDataUrl) return

    const map = mapRef.current
    const oldImageLayer = imageLayerRef.current

    // Calculate extent based on page size (at 150 DPI)
    const dpi = 150
    const scale = dpi / 72
    const extent: [number, number, number, number] = [0, 0, pageSize.width * scale, pageSize.height * scale]

    const projection = new Projection({
      code: "PDF",
      units: "pixels",
      extent,
    })

    const imageSource = new Static({
      url: pageDataUrl,
      projection,
      imageExtent: extent,
    })

    // Create new view with correct projection for this image
    const newView = new View({
      projection,
      center: [extent[2] / 2, extent[3] / 2],
      resolution: 1,
      minResolution: 0.1,
      maxResolution: 20,  // Allow zooming out far enough for large drawings
    })

    // Track zoom on new view
    newView.on("change:resolution", () => {
      const res = newView.getResolution()
      if (res) {
        setZoom(Math.round((1 / res) * 100))
      }
    })

    map.setView(newView)

    const imageLayer = new ImageLayer({ source: imageSource })

    imageSource.on("imageloadend", () => {
      // Remove old layer AFTER new one is ready (prevents flash)
      if (oldImageLayer) {
        map.removeLayer(oldImageLayer)
      }
      // Fit view after image loads - use multiple attempts to ensure DOM is ready
      const fitToView = () => {
        if (mapRef.current) {
          mapRef.current.updateSize()
          mapRef.current.getView().fit(extent, {
            padding: [20, 20, 20, 20],
            duration: 0
          })
        }
      }
      // Try immediately, then again after layout settles
      fitToView()
      setTimeout(fitToView, 100)
    })

    imageSource.on("imageloaderror", () => {
      setError("Failed to display page")
      // Remove old layer on error too
      if (oldImageLayer) {
        map.removeLayer(oldImageLayer)
      }
    })

    // Add new layer on top, will remove old one when loaded
    imageLayerRef.current = imageLayer
    map.getLayers().insertAt(0, imageLayer)

    // Initial fit attempt - will be refined by imageloadend and ResizeObserver
    map.updateSize()
    newView.fit(extent, { padding: [20, 20, 20, 20] })
  }, [pageDataUrl, pageSize])

  // Update markers when items change
  useEffect(() => {
    if (!vectorSourceRef.current) return

    vectorSourceRef.current.clear()

    // Calculate extent for coordinate conversion
    const dpi = 150
    const scale = dpi / 72
    const extentWidth = pageSize.width * scale
    const extentHeight = pageSize.height * scale

    // Track items without coordinates for fallback grid layout
    let gridIndex = 0

    items.forEach((item) => {
      let x: number
      let y: number

      if (item.pageX !== null && item.pageY !== null) {
        // Use real coordinates (normalized 0-1, convert to pixel coordinates)
        x = item.pageX * extentWidth
        y = (1 - item.pageY) * extentHeight // Flip Y axis (PDF Y is top-down)
      } else {
        // Fallback: distribute markers in grid pattern
        x = 100 + (gridIndex % 4) * 150
        y = 100 + Math.floor(gridIndex / 4) * 150
        gridIndex++
      }

      const feature = new Feature({
        geometry: new Point([x, y]),
        id: item.id,
        status: item.status,
        label: item.symbolCode || String(gridIndex || items.indexOf(item) + 1),
      })

      vectorSourceRef.current?.addFeature(feature)
    })
  }, [items, pageSize])

  // Update styles when selection changes
  useEffect(() => {
    vectorSourceRef.current?.changed()
  }, [selectedItemId])

  // Clear highlights when document or page changes
  useEffect(() => {
    if (highlightSourceRef.current) {
      highlightSourceRef.current.clear()
    }
  }, [documentId, pageNumber])

  // Update highlight layer when search terms change
  useEffect(() => {
    if (!highlightSourceRef.current) return

    // Clear existing highlights
    highlightSourceRef.current.clear()

    // Skip if no search terms or no document
    if (!highlightTerms.length || !documentId) return

    const fetchAndHighlight = async () => {
      try {
        // Fetch text positions for this page
        const res = await fetch(`/api/documents/${documentId}/page/${pageNumber}/text`)
        if (!res.ok) return

        const data = await res.json()
        const textPositions: TextPosition[] = data.textPositions || []
        const pdfPageHeight = data.pageHeight || 792
        const pdfPageWidth = data.pageWidth || 612

        // Check if dimensions match - if not, skip this render and wait for pageSize to update
        if (Math.abs(pageSize.width - pdfPageWidth) > 1 || Math.abs(pageSize.height - pdfPageHeight) > 1) {
          return
        }

        // Find matching positions
        const matches = findMatchingPositions(textPositions, highlightTerms)

        // Convert to OpenLayers coordinates and create features
        const dpi = 150

        for (const match of matches) {
          const rect = pdfToOLCoords(
            match.x,
            match.y,
            match.width,
            match.height,
            pdfPageHeight,
            dpi
          )

          // Create polygon for highlight rectangle
          // Rectangle extends UP from baseline (y) to (y + height)
          const feature = new Feature({
            geometry: new Polygon([[
              [rect.x, rect.y],
              [rect.x + rect.width, rect.y],
              [rect.x + rect.width, rect.y + rect.height],
              [rect.x, rect.y + rect.height],
              [rect.x, rect.y],
            ]]),
          })

          highlightSourceRef.current?.addFeature(feature)
        }
      } catch (err) {
        console.error("Failed to fetch text positions:", err)
      }
    }

    fetchAndHighlight()
  }, [highlightTerms, documentId, pageNumber, pageSize])

  // Zoom controls
  const handleZoomIn = () => {
    if (!mapRef.current) return
    const view = mapRef.current.getView()
    const res = view.getResolution()
    if (res) view.animate({ resolution: res / 1.5, duration: 200 })
  }

  const handleZoomOut = () => {
    if (!mapRef.current) return
    const view = mapRef.current.getView()
    const res = view.getResolution()
    if (res) view.animate({ resolution: res * 1.5, duration: 200 })
  }

  const handleFit = () => {
    if (!mapRef.current) return
    const view = mapRef.current.getView()
    const extent = view.getProjection().getExtent()
    if (extent) view.fit(extent, { padding: [20, 20, 20, 20], duration: 200 })
  }

  return (
    <div className="relative h-full w-full">
      {/* Map container */}
      <div
        ref={containerRef}
        className={cn(
          "h-full w-full bg-muted",
          (quickAddMode || symbolPickerMode) && "cursor-crosshair"
        )}
      />

      {/* Loading indicator - subtle spinner in corner, not a full overlay */}
      {loading && (
        <div className="absolute top-4 left-4 flex items-center gap-2 bg-background/80 backdrop-blur-sm rounded px-3 py-1.5 shadow-sm">
          <div className="h-3 w-3 border-2 border-primary border-t-transparent rounded-full animate-spin" />
          <span className="text-xs text-muted-foreground">Loading...</span>
        </div>
      )}

      {/* Error overlay */}
      {error && (
        <div className="absolute inset-0 flex items-center justify-center bg-background/50">
          <div className="text-sm text-destructive">{error}</div>
        </div>
      )}

      {/* Quick add mode indicator */}
      {quickAddMode && (
        <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-primary text-primary-foreground px-3 py-1 rounded text-sm">
          Click on the page to add an item
        </div>
      )}

      {/* Symbol picker mode indicator */}
      {symbolPickerMode && (
        <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-amber-600 text-white px-3 py-1 rounded text-sm flex items-center gap-2">
          <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
          Click on a symbol to find similar
        </div>
      )}

      {/* Extraction in progress indicator - prominent pulsing banner */}
      {extractionStatus === "extracting" && (
        <div className="absolute bottom-20 left-1/2 -translate-x-1/2 z-20">
          <div className="bg-blue-600 text-white px-6 py-3 rounded-lg shadow-lg flex items-center gap-3 animate-pulse">
            <div className="flex gap-1">
              <div className="w-2 h-2 bg-white rounded-full animate-bounce" style={{ animationDelay: "0ms" }} />
              <div className="w-2 h-2 bg-white rounded-full animate-bounce" style={{ animationDelay: "150ms" }} />
              <div className="w-2 h-2 bg-white rounded-full animate-bounce" style={{ animationDelay: "300ms" }} />
            </div>
            <span className="font-medium">AI is extracting signage items...</span>
          </div>
        </div>
      )}

      {/* Zoom controls */}
      <div className="absolute bottom-4 right-4 flex items-center gap-2 bg-background/90 backdrop-blur rounded-lg shadow-lg border px-2 py-1">
        <button
          onClick={handleZoomIn}
          className="px-3 py-1 hover:bg-secondary rounded text-sm font-medium"
        >
          +
        </button>
        <span className="text-xs text-muted-foreground min-w-[3rem] text-center">
          {zoom}%
        </span>
        <button
          onClick={handleZoomOut}
          className="px-3 py-1 hover:bg-secondary rounded text-sm font-medium"
        >
          âˆ’
        </button>
        <div className="w-px h-4 bg-border mx-1" />
        <button
          onClick={handleFit}
          className="px-2 py-1 hover:bg-secondary rounded text-xs"
        >
          Fit
        </button>
      </div>
    </div>
  )
}
